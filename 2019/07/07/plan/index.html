<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content>
  <meta name="author" content="Haita">
  <!-- Open Graph Data -->
  <meta property="og:title" content="Plan">
  <meta property="og:description" content="寻找之旅">
  <meta property="og:site_name" content="海獭之家">
  <meta property="og:type" content="article">
  <meta property="og:image" content="http://yoursite.com">
  
    <link rel="alternate" href="/atom.xml" title="海獭之家" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>海獭之家</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">Plan</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/asuraelvi1991">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:asuraelvi@163.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Haita</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2019-07-07</span>
            <span class="time">22:27:57</span>
          </span>
          
        </div>
        <!-- Tags -->
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h1 id="rpc测试框架"><a href="#rpc测试框架" class="headerlink" title="rpc测试框架"></a>rpc测试框架</h1><ul>
<li><p>单一应用架构，所有模块达成一个包，面对压力，可以扩展服务器，提供支持</p>
<pre><code>+ 缺点：不利于扩展，模块之间的修改会影响整个系统，系统会越来越大，运行时有压力，需要拆解模块</code></pre></li>
<li><p>垂直应用模块，将互不相关的模块拆成不同独立的子模块，</p>
<pre><code>+ 优点 
    1. 性能扩展 
    2. 分工合作容易
+ 缺点 
    1. 界面和业务逻辑未分离 
    2. 应用不可能完全独立，应用之间需要交互</code></pre></li>
<li><p>分布式服务架构</p>
<pre><code>+ 优点 
    1. 界面和业务逻辑分离 
+ 难点 
    1. 如何进行远程过程调用 rpc 
    2. 如何拆分业务</code></pre></li>
<li><p>流动计算架构 引入调度中心，实现实时的均衡，提高利用率</p>
<pre><code>+ HTTP 协议的缺陷 
  1. 通信过程中是使用明文，内容可能会被窃听 
  2. 不验证通信双方的身份 
  3. 无法验证报文的完整性，报文可能被篡改</code></pre></li>
<li><p>rest与rpc的区别</p>
<pre><code>+通信协议和序列化
    1. 序列化协议包括json、xml、hession、protobuf、thrift、text、bytes等；
    2. 通信协议比较流行的是http、soap、websockect，RPC通常基于TCP实现，常用框架例如dubbo，netty、mina、thrift。 
+ 定义
    1. Rest：严格意义上说接口很规范，操作对象即为资源，对资源的四种操作（post、get、put、delete），并且参数都放在URL上,
    但是不严格的说Http+json、Http+xml，常见的http api都可以称为Rest接口。
    2. Rpc:我们常说的远程方法调用，就是像调用本地方法一样调用远程方法，通信协议大多采用二进制方式
+ RPC的编程模型较重量级，REST的编程模型更轻量级
    1. RPC是面向动作的（方法调用）
    2. REST是面向资源的（URL表示资源，HTTP动词表示动作）</code></pre></li>
<li><p>http相对更规范，更标准，更通用，无论哪种语言都支持http协议。</p>
</li>
<li><p>RPC协议性能要高的多，例如Protobuf、Thrift、Kyro等，（如果算上序列化）吞吐量大概能达到http的二倍。响应时间也更为出色。</p>
</li>
<li><p>Rest 调用及测试都很方便，Rpc就显得有点麻烦，但是Rpc的效率是毋庸置疑的，所以建议在多系统之间采用Rpc，对外提供服务，Rest是很适合的duboo在生产者和消费者两个微服务之间的通信采用的就是Rpc,无疑在服务之间的调用Rpc更优秀</p>
</li>
<li><p>几种协议</p>
<pre><code>1. Socket使用时可以指定协议Tcp,Udp等；
2. RIM使用Jrmp协议，Jrmp又是基于TCP/IP；
3. RPC底层使用Socket接口，定义了一套远程调用方法；
4. HTTP是建立在TCP上，不是使用Socket接口，需要连接方主动发数据给服务器，服务器无法主动发数据个客户端；
5. Web Service提供的服务是基于web容器的，底层使用http协议，类似一个远程的服务提供者，</code></pre></li>
<li><p>测试client</p>
<pre><code>+ apache bench工具， 主要通过-c和-n来控制并发数和测试请求量。
    1. -c 指定并发的client,每个client都是独立的，在各自的goroutine或者Thread中运行。 Client采用同步的方式调用服务,也就是前一个服务调用完成后才发出下一个服务调用，因此并发量主要靠client的数量来确定。(当然有些rpc框架，比如rpcx/go std rpc支持异步调用，性能会更高，但是统一起见我们对所有的client都采用了同步调用的方式)
    2. -n 只发送服务的总的请求数，由client平分。</code></pre></li>
<li><p>测试指标</p>
<pre><code>+ 吞吐率: 每秒完成的请求量
+ 平均延迟: 服务发出到收到response所需的时间
+ P99延迟：99%的调用的延迟时间</code></pre><h1 id="apach-beanch"><a href="#apach-beanch" class="headerlink" title="apach beanch"></a>apach beanch</h1></li>
<li><p>根据ab命令可以创建很多的并发访问线程，模拟多个访问者同时对某一个URL地址进行访问，因此可以用来测试目标服务器的负载压力</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Usage: ab.exe [options] [http://]hostname[:port]/path</span><br><span class="line"> ab -c 1000 -n 3000 https://www.baidu.com/s?wd=rpc测试框</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">在使用ab命令时，并发了过高会出现错误：Too many open files，由于系统打开文件数量限制了。</span><br><span class="line">查看系统打开文件数量，命令：ulimit -a</span><br><span class="line"></span><br><span class="line">修改打开文件数量，修改成1024，命令：ulimit -n 1024</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server Software:        BWS/1.1</span><br><span class="line">Server Hostname:        www.baidu.com</span><br><span class="line">Server Port:            443</span><br><span class="line">SSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES128-GCM-SHA256,2048,128</span><br><span class="line">TLS Server Name:        www.baidu.com</span><br><span class="line"></span><br><span class="line">Document Path:          /s?wd=rpc测试框架</span><br><span class="line">Document Length:        227 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      1000</span><br><span class="line">Time taken for tests:   54.200 seconds</span><br><span class="line">Complete requests:      3000</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      2679000 bytes</span><br><span class="line">HTML transferred:       681000 bytes</span><br><span class="line">Requests per second:    55.35 [#/sec] (mean)</span><br><span class="line">Time per request:       18066.745 [ms] (mean)</span><br><span class="line">Time per request:       18.067 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          48.27 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:      231 9441 4987.8   7312   24191</span><br><span class="line">Processing:    30 2650 2495.7   1857   10222</span><br><span class="line">Waiting:       30 1699 2472.7   1172   10071</span><br><span class="line">Total:        299 12091 5175.5  13088   30494</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h1><ul>
<li><p>软件性能测试的目的主要有以下三点：<br>Ø  评价系统当前性能，判断系统是否满足预期的性能需求。<br>Ø  寻找软件系统可能存在的性能问题，定位性能瓶颈并解决问题。<br>Ø  判定软件系统的性能表现，预见系统负载压力承受力，在应用部署之前，评估系统性能。</p>
</li>
<li><p>而对于用户来说，则最关注的是当前系统：<br>Ø  是否满足上线性能要求？<br>Ø  系统极限承载如何？<br>Ø  系统稳定性如何？</p>
</li>
<li><p>性能测试监控关键指标说明：<br>Ø  资源指标</p>
<ol>
<li>CPU使用率：指用户进程与系统进程消耗的CPU时间百分比，长时间情况下，一般可接受上限不超过85%。</li>
<li>内存利用率：内存利用率=（1-空闲内存/总内存大小）*100%，一般至少有10%可用内存，内存使用率可接受上限为85%。</li>
<li>磁盘I/O: 磁盘主要用于存取数据，因此当说到IO操作的时候，就会存在两种相对应的操作，存数据的时候对应的是写IO操作，取数据的时候对应的是是读IO操作，一般使用% Disk Time（磁盘用于读写操作所占用的时间百分比）度量磁盘读写性能。</li>
<li>网络带宽：一般使用计数器Bytes Total/sec来度量，Bytes Total/sec表示为发送和接收字节的速率，包括帧字符在内。判断网络连接速度是否是瓶颈，可以用该计数器的值和目前网络的带宽比较。<br>Ø  系统指标：</li>
<li>并发用户数：某一物理时刻同时向系统提交请求的用户数。</li>
<li>在线用户数：某段时间内访问系统的用户数，这些用户并不一定同时向系统提交请求。</li>
<li>平均响应时间：系统处理事务的响应时间的平均值。事务的响应时间是从客户端提交访问请求到客户端接收到服务器响应所消耗的时间。对于系统快速响应类页面，一般响应时间为3秒左右。</li>
<li>事务成功率：性能测试中，定义事务用于度量一个或者多个业务流程的性能指标，如用户登录、保存订单、提交订单操作均可定义为事务，如下图所示：</li>
</ol>
</li>
<li><p>性能监控</p>
<ul>
<li>资源指标监控<ol>
<li>系统自带的性能监控工具或者第三方工具进行监控</li>
<li>命令行</li>
<li>公司开发的第三方可视化监控软件</li>
</ol>
</li>
<li>Ø  系统指标监控<ol>
<li>系统指标监控一般通过性能测试工具（如LoadRunner、Jmeter等）以图形化方式监控，并发用户数与平均响应时间关系图。</li>
</ol>
</li>
</ul>
</li>
<li><p>性能判断</p>
<ul>
<li><p>总结<br>  +大量的磁盘读写势必消耗CPU和IO资源，而内存的不足会导致频繁地进行内存页写入磁盘、磁盘写到内存的操作，造成磁盘IO瓶颈，同时， 大量的网络流量也会造成CPU过载，所以，在分析性能问题时，需要从各个方面进行考虑</p>
</li>
<li><p>资源指标</p>
<ol>
<li>cpu：CPU为瓶颈，主要从两方面：一是CPU空闲持续为 0，二是运行队列大于CPU核数（经验值3-4倍），即可判定存在瓶颈</li>
<li>判断内存是否是瓶颈的方法：一般至少有10%可用内存，内存使用率可接受上限为85%。</li>
<li>判断磁盘I/O是否是瓶颈的方法：<ul>
<li>计算每磁盘I/O数 过计算得到的每磁盘I/O数超过了磁盘标称的I/O能力</li>
<li>监控磁盘读写 如果磁盘长时间进行大数据量读写操作，且cpu等待超过20%，则说明磁盘I/O存在问          </li>
</ul>
</li>
<li>判断网络带宽是否是瓶颈的方法<ul>
<li>网络带宽是否会影响系统交易执行性能</li>
<li>ping应用服务器IP或网关IP，如果出现网络严重延迟或丢包，则说明网络不稳定，需要检查网络</li>
</ul>
</li>
</ol>
</li>
<li><p>系统指标</p>
<ol>
<li>并发用户数：系统能够支持的用户数是系统容量的重要标志，并发用户数用于度量系统在高并发量访问下，系统的并行处理能力，一般如果系统中存在死锁、资源争用，在并发访问下，由于请求处于队列等待中，系统响应就会随着时间变慢。<ul>
<li>一般情况下，选用高吞吐量、高数据库I/O、高商业风险的业务功能进行并发用户访问测试。</li>
<li>判断系统能够承受的最大并发用户数，通常以满足以下条件为准：<ol>
<li>业务功能操作平均响应时间在合理范围之内</li>
<li>事务成功率在合理范围之内</li>
<li>系统运行无故障（无异常宕机）</li>
<li>系统资源指标使用在合理范围内</li>
</ol>
</li>
</ul>
</li>
<li>平均响应时间：对于客户端用户来说，最直观的体验就是访问该页面快或者慢，即响应时 间的长短。<ul>
<li>先借助于监控到的资源指标，首先排除资源方面的限制因素</li>
<li>再从应用本身进行定位，如可以采用页面细分工具（如httpwatch、Loadrunner Anaysis中的页面组件细分）分析响应比较慢的页面           </li>
</ul>
</li>
<li>事务成功率、超时出错率<ul>
<li>事务成功率越高，则表明系统处理能力越大</li>
</ul>
</li>
</ol>
</li>
<li><p>软件性能测试是执行、监控—〉分析—〉调优不断进行的过程，即监控是为分析提供更多的参考数 据，分析是为了进行调优，调优是解决当前系统存在的性能瓶颈，为用户提供更好、更快的客户体验。                    </p>
</li>
</ul>
</li>
<li><p>不同的系统性能压力点不同</p>
<ol>
<li>门户网站、文件服务、政企办公：网络带宽瓶颈、缓存多（偏静）</li>
<li>流媒体应用、科学计算：进程多、消耗内存多、磁盘IO频繁（偏动）</li>
<li>企业生产应用：DB压力大、存储压力大、内存压力大、CPU压力大（动&amp;静）</li>
</ol>
</li>
<li><p>调优</p>
<ol>
<li>tomcat调优</li>
<li>jvm参数优化</li>
<li>最容易调优的地方 Java代码方面优化<br> 　　1. 减少new对象；用移位符号替代乘除号。<br> 　　2. 多使用局部变量，减少使用静态变量。<br> 　　3. 避免使用finalize,该方法会给GC增添很大负担；<br> 　　4. 如果是单线程，尽量使用非多线程安全的，因为线程安全来自于同步机制，同步机制会降低性能。<br> 　　5. 尽量使用基本类型而不是包装类型，尽量使用一维数组而不是二维数组。<br> 　　6. 尽量使用final修饰符,final表示不可修改，访问效率高。<br> 　　7. 单线程情况下，字符串尽量使用StringBuilder,比StringBuffer要快。</li>
<li>系统SQL分析调优<br>　　1. 主从复制<br>　　2. 静动分开（比如百度就是这样的）<br>　　3. 加数据库缓存<br>　　4. 设计优化（数据库、表结构、标的设计上需要优化）<br>　　5. 索引或视图减少查询内容<br>　　6. 优化SQL结构（通过explan优化sql的结构）    </li>
</ol>
</li>
</ul>
<p>+java 运行时参数<br>    1. -X 非标准化参数 输出非标准选项的帮助 使用不多<br>    2. - 比较稳定的选项 -version -help<br>    3. -XX 非标转化参数，相对不稳定 主要用于jvm调优和调试<br>        + boolean类型 -XX：[+-]<name>    +启用参数 -禁用参数<br>        + 非boolean类型 -XX：<key>=<value><br>    4. -Xms 初始化堆大小 -Xmx 最大堆大小 是-XX参数</value></key></name></p>
<ul>
<li>查看运行的java参数<ol>
<li>PrintFlagsFinal  java -XX:+PrintFlagsFinal -version 查看java进程的参数值，=是默认 ：=是修改后的值</li>
<li>jps -l 查看所有java程序进程 显示名字 详细参数使用方法参考java doc</li>
<li>jinfo 查看已经运行的参数 配合jps使用，需要进程号jinfo -flag MaxHeapSize 3974</li>
<li>jinfo -flags &lt;进程号&gt; 查看所有手动赋值的java运行参数</li>
<li>jstat 可以看jvm的统计信息 包括 类加载，垃圾回收（非常有用），jit编译 </li>
</ol>
</li>
<li>导出内存镜像文件<ol>
<li>自动导出 -XX：+HeapDumpOnOutOfMemoryError -XX：HeapDumpPath：/</li>
<li>使用jmap手动导出 jmap -dump:formatb,file=heap.hprof 4727 </li>
<li>可以用mat工具分析内存泄漏原因</li>
</ol>
</li>
<li>jstack实战死循环和死锁<ul>
<li>现象：CPU飙高，很有可能是有死循环和死锁<ul>
<li>top 【top -p 5626 -H】</li>
<li>printf “%x” number 十进制转16进制</li>
<li>jstack 分析内容 获取到pid jstack <pid> 即可获取到内容，根据线程nid可以查看死循环，根据内容末尾的死锁判断可以定位死锁</pid></li>
</ul>
</li>
<li>jvisualvm <ol>
<li>根据cpu 找热点方法，把经常调用用时长的方法进行分析</li>
<li></li>
</ol>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li>testng</li>
<li>机器学习</li>
</ol>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        </p><p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

