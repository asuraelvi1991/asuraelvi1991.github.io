<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content>
  <meta name="author" content="Haita">
  <!-- Open Graph Data -->
  <meta property="og:title" content="Spring Framework">
  <meta property="og:description" content="寻找之旅">
  <meta property="og:site_name" content="海獭之家">
  <meta property="og:type" content="article">
  <meta property="og:image" content="http://yoursite.com">
  
    <link rel="alternate" href="/atom.xml" title="海獭之家" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>海獭之家</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">Spring Framework</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/asuraelvi1991">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:asuraelvi@163.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Haita</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2019-06-29</span>
            <span class="time">22:51:05</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/Spring/">Spring</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/学习/">#学习</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h1 id="Interface-ApplicationContext-完整的身躯"><a href="#Interface-ApplicationContext-完整的身躯" class="headerlink" title="Interface ApplicationContext 完整的身躯"></a>Interface ApplicationContext 完整的身躯</h1><pre><code>+ All Superinterfaces:
+ ApplicationEventPublisher, BeanFactory, EnvironmentCapable, HierarchicalBeanFactory, ListableBeanFactory, MessageSource, 
ResourceLoader, ResourcePatternResolver
Central interface to provide configuration for an application. This is read-only while the application is running, 
but may be reloaded if the implementation supports this.
 为应用提供装配的中央核心接口。当应用启动起来后，这个接口处于只读状态，但是如果实现支持重载，则可以重新装载。

An ApplicationContext provides:
这个应用上下文提供
Bean factory methods for accessing application components. Inherited from ListableBeanFactory.
从ListableBeanFactory提供bean工厂方法取获取应用组件。
The ability to load file resources in a generic fashion. Inherited from the ResourceLoader interface.
从ResourceLoader继承了通过通用方式取家在文件资源的能力。
The ability to publish events to registered listeners. Inherited from the ApplicationEventPublisher interface.
从ApplicationEventPublisher提供了发布消息给注册监听者的能力。
The ability to resolve messages, supporting internationalization. Inherited from the MessageSource interface.
继承了MessageSource提供了解决信息，支持交互的能力。
Inheritance from a parent context. Definitions in a descendant context will always take priority. 
This means, for example, that a single parent context can be used by an entire web application, 
while each servlet has its own child context that is independent of that of any other servlet.
对于父类上下文的子类，定义在后代中的内容会一直拥有优先权。这就表明，一个单独的父类上下文可以被用作一个问政的web应用，
但是每一个servlet会拥有它的子类上下文，他们都是相互独立的。

主要实现类ClassPathXmlApplicationContext（默认从类路径加载配置项）和FileSystemXmlApllicationContext（默认从文件系统加载）
# [类路径][https://www.cnblogs.com/f-ck-need-u/p/8127529.html]
类路径：即发布到Tomcat服务器后的ClassPath路径:在IDEA中即resource路径(在Idea中有两个resource目录).

[!!!] AnnotationConfigApplicationContext 基于注解类的配置实现类
beanFactory初始化容器时候未初始化bean，知道第一次访问才实例化
ApplicationContext在初始化应用上下文时就实例化所有单例的bean

webApplicationContext专门为web应用准备，允许从相对于web根目录的路径中装载配置文件。
ConfigurableWebApplication拓展了webApplicationContext，spiring的配置文件地址，是相对于web根目录的地址，例如/web-inf/baobaotao.xml,
用户也可以使用带资源类型前缀的地址例如 classpath：com/baobaotao/beans.xml

Spring提供了用于启动webApplicationContext的servlet和web容器监听器
    contextLoaderServlet
    ContextLoaderListener
web三大组件 servlet，filter，listener</code></pre><h1 id="资源访问利器"><a href="#资源访问利器" class="headerlink" title="资源访问利器"></a>资源访问利器</h1><h2 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h2><pre><code>Strategy interface for loading resources (e.. class path or file system resources). 
An ApplicationContext is required to provide this functionality, plus extended ResourcePatternResolver support.
装载资源的策略接口，应用上下文需要提供这个功能，需要额外得到ResourcePatternResolver的支持</code></pre><h2 id="ResourcePatternResolver"><a href="#ResourcePatternResolver" class="headerlink" title="ResourcePatternResolver"></a>ResourcePatternResolver</h2><pre><code>Strategy interface for resolving a location pattern (for example, an Ant-style path pattern) into Resource objects.
解决地址格式转化为资源对象的一个策略接口，支持ant-style、通配符等等</code></pre><h2 id="PathMatchingResourcePatternResolver"><a href="#PathMatchingResourcePatternResolver" class="headerlink" title="PathMatchingResourcePatternResolver"></a>PathMatchingResourcePatternResolver</h2><pre><code>A ResourcePatternResolver implementation that is able to resolve a specified resource location path into one or 
more matching Resources. The source path may be a simple path which has a one-to-one mapping to a target Resource, 
or alternatively may contain the special &quot;classpath*:&quot; prefix and/or internal Ant-style regular expressions 
(matched using Spring&apos;s AntPathMatcher utility). Both of the latter are effectively wildcards.
ResourcePatternResolver实现了解决将特殊资源路径转变为一个或多个匹配资源的功能。原路径可能是一个简单一对一的路径，或者可能是包含通配符
或者特定classpath*、或ant-style的路径。</code></pre><h1 id="Bean工厂-sping的心脏"><a href="#Bean工厂-sping的心脏" class="headerlink" title="Bean工厂 sping的心脏"></a>Bean工厂 sping的心脏</h1><pre><code>通过配置文件描述bean之间的依赖关系，利用java反射功能实例化bean并建立bean之间依赖关系。</code></pre><h2 id="Spring最核心的接口-BeanFacotry"><a href="#Spring最核心的接口-BeanFacotry" class="headerlink" title="Spring最核心的接口 BeanFacotry"></a>Spring最核心的接口 BeanFacotry</h2><pre><code>1-beanFactory是Spring框架的基础设施，面向spring
applicationContext面向使用spring框架的开发者，几乎所有应用场合我们都直接使用applicationcontext
2-javabean 必须提供一个不带参数的构造函数、不依赖于某一特定的容器</code></pre><h3 id="XmlBeanFactory"><a href="#XmlBeanFactory" class="headerlink" title="XmlBeanFactory"></a>XmlBeanFactory</h3><pre><code>1.beanFactory 在类结构的顶端，提供从容器中返回特定名称的bean，beanfactory通过其他的接口得到不断的扩展
2.listableBeanFactory 查看bean的个数、获取某一类型bean的配置名、查看容器中是否包括某一bean等方法
3.hierarchicalBeanFactory 父子级联ioc容器的接口，子接口可以通过接口方法访问父容器
4.configurablebeanfactory 重要接口，增强了ioc容器的可定制型，定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法
5.autowirecapablebeanfactory 讲容器中bean按照某种规则（如按照名字匹配、按类型匹配等）进行自动装配的国防法
6.singletonbeanregistry 定义了允许在运行期间向容器注册单例bean的方法
7.beandefinitionregistry spring配置文件中每一个bean节点元素在spring容器里都通过一个beandefinition对象表示，描述bean的配置信息。
beandefinitionregistry提供了想容器手工注册beandefinition对象的方法
8.XmlBeanFactory继承自DefaultListableBeanFactory，而DefaultListableBeanFactory是整个bean加载的核心部分，是Spring注册及加载
bean的默认实现，而对于XmlBeanFactory和DefaultListableBeanFactory不同的地方其实是在XmlBeanFactory中使用了自定义的XML读取器
XmlBeanDefinitionReader，实现了个性化的BeanDefinitionReader读取。
9.DefaultSingletonBeanRegistry中提供了一个用于缓存单例bean的缓存器，用一个hashmap实现的缓存器，以beanName为键保存在这个hashmap中</code></pre><h1 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h1><pre><code>beanPostProcessor在spring框架中有重要的地位，为容器提供对bean进行后续加工处理的切入点，spring容器所提供的各种&quot;神奇功能&quot;，就是通过beanpostProcessor实施的
1.bean自身的方法：如调用bean构造方法实例化bean，调用setter设置bean的是行之，init-method、destroy-method
2.bean级生命周期接口方法：beanNameAware、BeanFacotryAware、InitializingBean和DisposableBean
3.容器级生命周期接口方法：instatiationAwareBeanPostProcessor和BeanPostProcessor这两个接口实现，后处理器。

bean级生命周期接口，解决的是bean个性化处理问题；容器级生命周期接口，解决的是某些bean共性化处理的问题。
applicationContext与beanfactory的区别在于：前者会利用java反射机制自动识别出配置文件中定义的beanPostProcessor、
InstantiationAwareBeanPostProcessor和beanfactoryPostProcessor，并自动将他们注册到应用上下文。后者需要在代码中手动添加。
（因此应用中一般使用applicationContext）</code></pre><h1 id="IOC总结"><a href="#IOC总结" class="headerlink" title="IOC总结"></a>IOC总结</h1><pre><code>1.控制是接口实现类的选择控制权
2.翻转是从调用类转移到外部第三方类或容器的手中
3.BeanFactory、ApplicationContext、WebApplicationContext是Spring框架的三个最核心接口
4.Resource实现了框架与具体资源的接口
5.Resource与ResourceLoader配合，ResourceLoader采用了策略模式   </code></pre><h1 id="bean的不同配置"><a href="#bean的不同配置" class="headerlink" title="bean的不同配置"></a>bean的不同配置</h1><pre><code>1.书的p133
2.xml配置的适合场景：第三方类库的实现类，如DataSource、JdbcTemplate等、因为无法在勒种标注注解，通过xml比较好
3.命名空间的配置、如aop、context等智能采用XML的配置
4.Bean的实现类是当前项目开发的，可以直接在java类上使用注解的配置
5.基于java类配置：通过代码方式控制beans的初始化逻辑，如果逻辑比较复杂，使用java类配置</code></pre><h1 id="Spring组件"><a href="#Spring组件" class="headerlink" title="Spring组件"></a>Spring组件</h1><pre><code>1.物料组件： Resource、BeanDefinition、PropertyEditor以及最终的Bean，是加工流程中被加工、被消费的组件
2.加工设备组件：ResourceLoader、BeanDefinitionReader、BeanFactoryPostProcessor、InstantiationStrategy灯组件，像是流水线上不同环节的加工设备，对物料进行加工处理</code></pre><h1 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h1><pre><code>1.abstractBean是对RootBeanDefinition和ChildBeanDefinition共同的类信息进行的抽象
2.BeanDefinitionRegistry是spring配置信息的内存数据库
3.通过XML解析器解析配置信息的DOM对象，生成对应的beanDefinition对象，此时可能是半成品。利用容器中注册的BeanFactoryPostProcessor对半成品进行加工
，将以占位符表示的配置解析为最终的实际值</code></pre><p>#InstantiationStrategy<br>    1.根据BeanDefinition对象创建一个bean实例<br>    2.simpleInstantiationStrategy利用bean实现类的默认构造函数、带参构造函数或工厂方法创建Bean的实例<br>    3.CglibSubclassingInstantiationStrategy扩展了simpleInstantiationStrategy，利用CGLib类库为bean动态生成子类，<br>    在子类中生成方法注入的逻辑，然后使用这个动态生成的子类创建Bean的实例<br>    4.相当于执行java的new的功能，并不会参与属性的设置工作，属性的填充工作留待BeanWrapper来完成</p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        </p><p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

